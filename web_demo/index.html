<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Disable zooming: -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<head>
    <title>egui_ltreeview - A treeview widget for egui</title>
    <style>
        html {
            /* Remove touch delay: */
            touch-action: manipulation;
        }

        body {
            /* Light mode background color for what is not covered by the egui canvas,
            or where the egui canvas is translucent. */
            background: #909090;
        }

        @media (prefers-color-scheme: dark) {
            body {
                /* Dark mode background color for what is not covered by the egui canvas,
                or where the egui canvas is translucent. */
                background: #404040;
            }
        }

        /* Allow canvas to fill entire web page: */
        html,
        body {
            overflow: hidden;
            margin: 0 !important;
            padding: 0 !important;
            height: 100%;
            width: 100%;
        }

        /* Make canvas fill entire document: */
        canvas {
            margin-right: auto;
            margin-left: auto;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="the_canvas_id"></canvas>
    <script type="module">
        // Use ES module import syntax to import functionality from the module
        // that we have compiled.
        //
        // Note that the `default` import is an initialization function which
        // will "boot" the module and make it ready to use. Currently browsers
        // don't support natively imported WebAssembly as an ES module, but
        // eventually the manual initialization won't be required!
        import init from './playground.js';

        async function run() {
            // First up we need to actually load the Wasm file, so we use the
            // default export to inform it where the Wasm file is located on the
            // server, and then we wait on the returned promise to wait for the
            // Wasm to be loaded.
            //
            // It may look like this: `await init('./without_a_bundler_bg.wasm');`,
            // but there is also a handy default inside `init` function, which uses
            // `import.meta` to locate the Wasm file relatively to js file.
            //
            // Note that instead of a string you can also pass in any of the
            // following things:
            //
            // * `WebAssembly.Module`
            //
            // * `ArrayBuffer`
            //
            // * `Response`
            //
            // * `Promise` which returns any of the above, e.g. `fetch("./path/to/wasm")`
            //
            // This gives you complete control over how the module is loaded
            // and compiled.
            //
            // Also note that the promise, when resolved, yields the Wasm module's
            // exports which is the same as importing the `*_bg` module in other
            // modes
            await init();

            // // And afterwards we can use all the functionality defined in wasm.
            // const result = add(1, 2);
            // console.log(`1 + 2 = ${result}`);
            // if (result !== 3)
            //     throw new Error("wasm addition doesn't work!");
        }

        run();
    </script>
</body>

</html>